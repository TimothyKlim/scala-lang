<figure class="code concurrency" style="width: 450px; margin-top: 20px;">
  <figcaption>Concurrent/Distributed</figcaption>
  <pre><code>val x = future { someExpensiveComputation() }
val y = future { someOtherExpensiveComputation() }
val z = for (a &lt;- x; b &lt;- y) yield a * b
for (c &lt;- z) println("Result: " + c)
println("Meanwhile, the main thread goes on!")</code></pre>
</figure>

<div class="snippet-explanation">
  <h3>Go Concurrent or Distributed with Futures &amp; Promises</h3>
  <p>In Scala, futures and promises can be used to process data <i>asynchronously</i>, making it easier to parallelize or even distribute your application.</p>
  <p>In this example, the <code>future{}</code> construct evaluates its argument asynchronously, and returns
     a handle to the asynchronous result as a <code>Future[Int]</code>.
     For-comprehensions can be used to register new callbacks (to post new things to do) when the future is
     completed, i.e., when the computation is finished.
     And since all this is executed asynchronously, without blocking, the main
     program thread can continue doing other work in the meantime.</p>
</div>
